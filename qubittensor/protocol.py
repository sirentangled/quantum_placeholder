from pydantic import BaseModel, Field
from typing import Optional
import bittensor as bt # Import bittensor to access bt.Synapse

# Base structure for common fields
class CircuitSynapseBase(bt.Synapse): # <--- CHANGE MADE HERE: Inherit from bt.Synapse
    """
    Base class for circuit-related synapses, defining common fields.
    """
    validator_signature: Optional[str] = Field(
        None,
        description="A cryptographic signature from the validator's hotkey, verifying authenticity and traceability.",
        json_schema_extra={"empty_field": True} # Custom hint for empty synapse
    )
    circuit_data: Optional[str] = Field(
        None,
        description="serialized circuit description",
        json_schema_extra={"empty_field": True}
    )
    solution_hash: Optional[str] = Field(
        None,
        description="hash of the expected output",
        json_schema_extra={"empty_field": True}
    )
    difficulty_level: Optional[int] = Field(
        None,
        description="integer representing the difficulty level of the circuit.",
        json_schema_extra={"empty_field": True}
    )

    # Add a deserialize method as required by bt.Synapse
    def deserialize(self) -> str:
        """
        Deserializes the response content. In this case, it can return the solution hash,
        or the entire synapse if you need to access all fields.
        """
        return self.solution_hash if self.solution_hash is not None else ""


# Synapse for miners to fill in (empty fields)
class CompletedCircuits(CircuitSynapseBase):
    """
    Synapse for miners to submit completed circuits.
    All fields are initially empty and to be populated by the miner upon solution.
    """
    # No additional fields needed, inherits from CircuitSynapseBase
    pass

# Synapse for validators to send populated challenges
class ChallengeCircuits(CircuitSynapseBase):
    """
    Synapse for validators to send circuit challenges to miners.
    All fields will be populated by the validator.
    """
    # No additional fields needed, inherits from CircuitSynapseBase
    pass

# Example of how these would be used (conceptual)

# 1. Validator creates a ChallengeCircuits instance to send to miners
validator_challenge = ChallengeCircuits(
    validator_signature="0xVALIDSIGNATURE...", # Generated by the validator's hotkey
    circuit_data="{'gate_type': 'AND', 'inputs': [1,0]}", # Example circuit data
    solution_hash="0xEXPECTEDSOLUTIONHASH...", # Hash of the expected output/solution
    difficulty_level=1
)

miner_completed_circuit = CompletedCircuits(
    validator_signature=validator_challenge.validator_signature, # Keep original validator signature
    circuit_data=validator_challenge.circuit_data, # Original circuit data
    solution_hash="0xMINERSOLUTIONSUBMISSIONHASH...", # Miner's computed hash of the solution
    difficulty_level=validator_challenge.difficulty_level # Original difficulty
    # You might also add a 'miner_solution' field if the actual solution (not just its hash)
    # is to be returned by the miner.
)

print("Validator challenge example:")
print(validator_challenge.model_dump_json(indent=2))

print("\nCompletedCircuits (sent by miner):")
print(miner_completed_circuit.model_dump_json(indent=2))